# 요청 라이프사이클 (Request Lifecycle)

- [소개](#introduction)
- [라이프사이클 개요](#lifecycle-overview)
    - [첫 단계](#first-steps)
    - [HTTP / 콘솔 커널](#http-console-kernels)
    - [서비스 제공자(Service Providers)](#service-providers)
    - [라우팅](#routing)
    - [마무리](#finishing-up)
- [서비스 제공자 집중 탐구](#focus-on-service-providers)

<a name="introduction"></a>
## 소개

실제 환경에서 어떤 도구를 사용할 때, 그 도구가 어떻게 작동하는지 이해한다면 훨씬 더 자신감이 생깁니다. 애플리케이션 개발도 마찬가지입니다. 개발 도구가 어떻게 기능하는지 이해하면 좀 더 편안하고 자신 있게 도구를 사용할 수 있습니다.

이 문서의 목적은 Laravel 프레임워크가 어떻게 작동하는지에 대한 전반적이고 큰 그림의 개요를 제공하는 것입니다. 프레임워크 전체 구조를 이해하면 모든 것이 덜 ‘마법같이’ 느껴지고 애플리케이션 개발에 더 자신감을 가질 수 있습니다. 처음에 모든 용어를 완벽히 알지 못해도 괜찮습니다! 기본적으로 무슨 일이 벌어지는지 감을 잡고, 문서의 다른 부분을 탐색하면서 지식을 차근차근 키워가면 됩니다.

<a name="lifecycle-overview"></a>
## 라이프사이클 개요

<a name="first-steps"></a>
### 첫 단계

모든 Laravel 애플리케이션 요청의 진입점은 `public/index.php` 파일입니다. 모든 요청은 웹 서버(Apache 또는 Nginx) 설정을 통해 이 파일로 전달됩니다. `index.php` 파일 자체는 많은 코드를 포함하지 않으며, 오히려 프레임워크의 나머지 부분을 불러오는 시작점 역할을 합니다.

`index.php` 파일은 Composer가 생성한 자동 로더 정의를 불러오고, `bootstrap/app.php`에서 Laravel 애플리케이션 인스턴스를 가져옵니다. Laravel이 수행하는 첫 번째 작업은 애플리케이션 / [서비스 컨테이너](/docs/10.x/container) 인스턴스를 생성하는 것입니다.

<a name="http-console-kernels"></a>
### HTTP / 콘솔 커널

그 다음, 들어오는 요청은 요청 유형에 따라 HTTP 커널 또는 콘솔 커널로 전달됩니다. 이 두 커널은 모든 요청이 거쳐 가는 중앙 허브 역할을 합니다. 지금은 `app/Http/Kernel.php`에 위치한 HTTP 커널에 집중해 봅시다.

HTTP 커널은 `Illuminate\Foundation\Http\Kernel` 클래스를 상속하며, 요청 처리 전에 실행되는 `bootstrappers` 배열을 정의합니다. 이 부트스트래퍼들은 예외 처리 설정, 로깅 설정, [애플리케이션 환경 감지](/docs/10.x/configuration#environment-configuration) 등 요청을 처리하기 전에 꼭 수행해야 하는 작업들을 합니다. 보통 이 클래스들은 Laravel 내부 구성에 관련된 작업을 하므로 개발자가 직접 신경 쓸 필요는 없습니다.

HTTP 커널은 또한 모든 요청이 애플리케이션에 의해 처리되기 전 반드시 거쳐야 하는 HTTP [미들웨어](/docs/10.x/middleware) 목록을 정의합니다. 이 미들웨어들은 HTTP [세션 읽기 및 쓰기](/docs/10.x/session), 애플리케이션 유지보수 모드 확인, [CSRF 토큰 검증](/docs/10.x/csrf) 등을 담당합니다. 이 부분은 곧 자세히 다루겠습니다.

HTTP 커널의 `handle` 메서드는 시그니처가 매우 간단합니다: `Request`를 받아 `Response`를 반환합니다. 커널은 전체 애플리케이션을 나타내는 큰 검은 상자처럼 생각하면 됩니다. HTTP 요청을 넣으면 HTTP 응답을 돌려줍니다.

<a name="service-providers"></a>
### 서비스 제공자(Service Providers)

커널 부트스트래핑 과정에서 가장 중요한 작업 중 하나는 애플리케이션의 [서비스 제공자](/docs/10.x/providers)를 불러오는 것입니다. 서비스 제공자는 데이터베이스, 큐, 유효성 검사, 라우팅 컴포넌트 등 프레임워크 여러 구성 요소를 부트스트랩하는 역할을 합니다. 애플리케이션의 모든 서비스 제공자는 `config/app.php` 설정 파일의 `providers` 배열에 정의되어 있습니다.

Laravel은 이 `providers` 목록을 순회하며 각 제공자 인스턴스를 생성합니다. 인스턴스 생성 직후 각 제공자의 `register` 메서드를 호출합니다. 모든 제공자가 등록이 완료되면 이어서 각 제공자의 `boot` 메서드를 호출합니다. 이렇게 하는 이유는 서비스 제공자들이 자신의 `boot` 메서드가 실행될 때 모든 컨테이너 바인딩이 등록되어 있어야 하기 때문입니다.

요약하면, Laravel이 제공하는 주요 기능 대부분은 서비스 제공자에 의해 부트스트랩되고 설정됩니다. 프레임워크의 많은 기능을 부트스트랩하고 설정하는 만큼, 서비스 제공자는 Laravel 부트스트랩 프로세스에서 가장 중요한 요소입니다.

<a name="routing"></a>
### 라우팅

애플리케이션에서 가장 중요한 서비스 제공자 중 하나는 `App\Providers\RouteServiceProvider`입니다. 이 서비스 제공자는 애플리케이션의 `routes` 디렉터리 내의 라우트 파일을 불러옵니다. 직접 `RouteServiceProvider` 코드를 열어 어떻게 동작하는지 살펴보시기 바랍니다!

애플리케이션 부트스트랩과 서비스 제공자 등록이 끝나면, `Request`는 라우터로 전달되어 디스패치됩니다. 라우터는 요청을 적절한 라우트 또는 컨트롤러로 보내고 해당 라우트에 할당된 미들웨어를 실행합니다.

미들웨어는 애플리케이션에 들어오는 HTTP 요청을 필터링하거나 검사하는 편리한 메커니즘입니다. 예를 들어, Laravel에는 애플리케이션 사용자가 인증되었는지 확인하는 미들웨어가 포함되어 있습니다. 사용자가 인증되지 않았다면 미들웨어는 로그인 화면으로 리다이렉트하고, 인증된 경우 요청을 애플리케이션 내에서 더 진행시킵니다. 일부 미들웨어는 HTTP 커널의 `$middleware` 속성에 정의되어 애플리케이션 내 모든 라우트에 할당됩니다. 반면 특정 라우트나 라우트 그룹에만 할당되는 미들웨어도 있습니다. 미들웨어에 대해 더 알고 싶다면 전체 [미들웨어 문서](/docs/10.x/middleware)를 참고하세요.

요청이 매칭된 라우트에 할당된 모든 미들웨어를 통과하면, 라우트 또는 컨트롤러 메서드가 실행되고 여기서 반환된 응답이 다시 라우트에 할당된 미들웨어 체인을 거쳐 반환됩니다.

<a name="finishing-up"></a>
### 마무리

라우트 또는 컨트롤러 메서드가 응답을 반환하면, 응답은 다시 라우트의 미들웨어를 거치며 애플리케이션이 응답을 수정하거나 검사할 기회를 갖게 됩니다.

마지막으로, 응답이 모든 미들웨어를 통과해 다시 돌아오면, HTTP 커널의 `handle` 메서드가 응답 객체를 반환하고 `index.php` 파일에서 이 응답의 `send` 메서드를 호출합니다. `send` 메서드는 응답 내용을 사용자의 웹 브라우저로 전송합니다. 이렇게 해서 Laravel 요청 라이프사이클의 전체 여정을 마쳤습니다!

<a name="focus-on-service-providers"></a>
## 서비스 제공자 집중 탐구

서비스 제공자는 Laravel 애플리케이션을 부트스트랩하는 핵심 열쇠입니다. 애플리케이션 인스턴스가 생성되고, 서비스 제공자가 등록되며, 요청이 부트스트랩된 애플리케이션에 전달됩니다. 이것이 전부입니다!

서비스 제공자를 통해 Laravel 애플리케이션이 어떻게 구성되고 부트스트랩되는지 확실히 이해하는 것은 매우 중요합니다. 애플리케이션의 기본 서비스 제공자들은 `app/Providers` 디렉터리에 저장되어 있습니다.

기본적으로 `AppServiceProvider`는 비교적 비어 있습니다. 이 제공자는 애플리케이션 고유의 부트스트랩 작업이나 서비스 컨테이너 바인딩을 추가하기에 좋은 위치입니다. 대규모 애플리케이션은 필요에 따라 여러 서비스 제공자를 만들어, 각각 특정 서비스 부트스트랩을 더 세분화해서 관리할 수도 있습니다.